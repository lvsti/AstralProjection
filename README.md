## Astral Projection


### Introduction

Astral Projection (from hereon aka 'AP') is an extension to the iOS/OSX CoreLocation framework which can make testing of location-aware applications easier.


### The name

From Wikipedia: "Astral projection (or astral travel) is an interpretation of any form of out-of-body experience (OBE) that assumes the existence of an 'astral body' separate from the physical body and capable of travelling outside it."


### What is it good for?

Generally, apps that use location data can only be tested well when deployed on the device but hardware builds aren't of much help if the wandering "range" is limited to the length of the USB cable (e.g. in case of on-device debugging). Unfortunately, the developer tools traditionally offer very basic facilities for returning GPS coordinates. Recent versions of Xcode have shown certain improvements, e.g. the support for GPX files, but there is still no way of getting heading information and interfering with the trajectory. This is when AP enters the scene.

Astral Projection is a set of tools which allow you to generate fake location-related data that normally comes from the underlying hardware such as GPS, WiFi or 3G. AP is bundled with a couple of data sources which you can use right away or, should you require a custom one, you can also add your own modules complying with a simple interface. 


### How do I use it?

AP consists of a core and an optional set of data sources. The main class is `APAstralProjection` which basically hijacks the `CLLocationManager` class and its instances so while your code still thinks it is interacting with the location manager, in reality it is `APAstralProjection` who is pulling the strings. Location events are generated by data sources you specify and delivered by AP to the respective `CLLocationManager` delegates as if they were coming from the location managers themselves.

Location data sources are classes conforming to the `APLocationDataSource` protocol. Data sources take a reference to a delegate of `APLocationDataDelegate` kind (set automatically to the `APAstralProjection` instance when installed) which they notify about location changes appropriately, according to their own implementation. Similarly, heading data sources comply with `APHeadingDataSource` and are responsible for handing over heading information.

Currently AP comes with two built-in data sources:

- `APGPXDataSource` (location only): loads a GPX file and uses its waypoints, routes or tracks as location change event source. "Playback" can be speeded up/slown down by means of a time scale. If the point set does not have timestamps (waypoints usually don't), it is also possible to emit the points at a given frequency.

- `APAgentDataSource` (location + heading): uses the location and heading data of a "field agent", transmitted through the network in real-time. The agent can be any iOS device with the bundled `APAgent` app installed. The agent sends its location information in UDP packets to a configurable IP address-port where the `APAgentDataSource` is supposed to be listening. `APAgentDataSource` then reports the extracted location data to the location manager.

To control the application-wide state of the CoreLocation framework, such as availability flags, you can provide a delegate of `APAstralProjectionDelegate` kind whose return values are then wired into the global location manager.


### OK, but how does it work?

Historically, AP provided `APLocationManager`, a custom subclass of `CLLocationManager` which you would then use as a replacement, but I noticed that this hack no longer works in recent OSX SDKs, yielding various build-time and run-time errors. Another annoyance was that if you used multiple instances of the location manager across your app you would have to configure them one by one to achieve a more or less consistent behavior. 

As of now, AP rather hijacks the `CLLocationManager` class and its instances by means of Objective-C categories and method swizzling. Class methods are swizzled to take their values from the appropriate `APAstralProjectionDelegate` call, while instance methods are simply overwritten with the help of categories. This way the original `CLLocationManager` is reduced to a mere fa√ßade.

DISCLAIMER: Method swizzling and category overrides are DANGEROUS PRACTICES and I strongly advise against them hitting production code. Take special care if you are binding to `CLLocationManager` properties with KVO as I haven't tested that scenario and KVO is very likely to interfere with the mentioned hacks. YOU HAVE BEEN WARNED.


### Known limitations

Currently AP is limited to location and heading data, that is, no significant-change, no regions, no nothing. In the future this may change if I happen to need that stuff or if I find an enthusiastic volunteer to code it for everyone's sake. :)

Please also note that, owing to its nature, AP is not capable of waking your app on location events. For that you can always revert to the functionality provided by the developer tools.

For feature requests, please visit the GitHub [issue tracking page](https://github.com/lkxf/AstralProjection/issues) and leave your comments there.


### Installation

Requirements: iOS 5.0 or above, OS X 10.6 or above

Here are some guidelines for setting up AP in your project:
- check out the latest revision
- add the `Core` files to your project 
- add one or more data sources (note that `APAgentDataSource` depends on JSON, if you add this data source you have to add Stig Brautaset's `SBJSON` too -- see the `ThirdParty` folder for a legacy version)

Some hints on how to integrate it in your code (see the `APMobileHost` and `APDesktopHost` sample apps for details):
- instantiate and set up the desired data source(s)
- pass the data source(s) to `APAstralProjection` via the respective properties
- kick off the data source by invoking `startGeneratingLocationEvents`


### Contact

In case of doubts, bug reports or feature requests, you are welcome to visit the project home page at:

http://github.com/lkxf/AstralProjection



Enjoy!

lkxf



