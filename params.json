{"name":"Astral Projection","tagline":"Location testing for iOS and OSX","body":"### Introduction\r\n\r\nAstral Projection (from hereon aka 'AP') is an extension to the iOS CoreLocation framework which can make testing of location-aware iPhone/iPad applications easier.\r\n\r\n\r\n### The name\r\n\r\nFrom Wikipedia: \"Astral projection (or astral travel) is an interpretation of any form of out-of-body experience (OBE) that assumes the existence of an 'astral body' separate from the physical body and capable of travelling outside it.\"\r\n\r\n\r\n### What is it good for?\r\n\r\nGenerally, apps that use location data can only be tested well when deployed on the device. The simulator has limited facilities for returning GPS coordinates, and the hardware builds worth equally little if the wandering \"range\" is limited to the length of the USB cable (e.g. in case of on-device debugging). But even if you are fine with deploying, how would you test use cases which involve motion and you don't get a damn fix in the whole office? This is when AP enters the scene.\r\n\r\nAstral Projection is a set of tools which allow you to generate fake location-related data that normally comes from the underlying hardware such as GPS, WiFi or 3G. AP is bundled with a couple of data sources which you can use right away, or, should you require a custom one, you can also add your own modules complying with a simple interface. \r\n\r\n\r\n### How do I use it?\r\n\r\nAP consists of a core and an optional set of data sources. The main class is `APAstralProjection` which basically hijacks the `CLLocationManager` class and its instances so while your code still thinks it is interacting with the location manager, in reality it is `APAstralProjection` who is pulling the strings. Location events are generated by data sources you specify and delivered by AP to the respective `CLLocationManager` delegates as if they were coming from the location managers themselves.\r\n\r\nLocation data sources are classes conforming to the `APLocationDataSource` protocol. Data sources take a reference to a delegate of `APLocationDataDelegate` kind (set automatically to the `APAstralProjection` instance when installed) which they notify about location changes appropriately, according to their own implementation. Similarly, heading data sources comply with `APHeadingDataSource` and are responsible for handing over heading information.\r\n\r\nCurrently AP comes with two built-in data sources:\r\n\r\n * `APGPXDataSource` (location only): loads a GPX file and uses its waypoints, routes or tracks as location change event source. \"Playback\" can be speeded up/slown down by means of a time scale. If the point set does not have timestamps (waypoints usually don't), it is also possible to emit the points at a given frequency.\r\n\r\n * `APAgentDataSource` (location + heading): uses the location and heading data of a \"field agent\", transmitted through the network in real-time. The agent can be any iOS device with the bundled `APAgent` app installed. The agent sends its location information in UDP packets to a configurable IP address-port where the `APAgentDataSource` is supposed to be listening. `APAgentDataSource` then reports the extracted location data to the location manager.\r\n\r\nTo control the application-wide state of the CoreLocation framework, such as availability flags, you can provide a delegate of `APAstralProjectionDelegate` kind whose return values are then wired into the global location manager.\r\n\r\n\r\n### OK, but how does it work?\r\n\r\nHistorically, AP provided `APLocationManager`, a custom subclass of `CLLocationManager` which you would then use as a replacement, but I noticed that this hack no longer works in recent OSX SDKs, yielding various build-time and run-time errors. Another annoyance was that if you used multiple instances of the location manager across your app you would have to configure them one by one to achieve a more or less consistent behavior. \r\n\r\nAs of now, AP rather hijacks the `CLLocationManager` class and its instances by means of Objective-C categories and method swizzling. Class methods are swizzled to take their values from the appropriate `APAstralProjectionDelegate` call, while instance methods are simply overwritten with the help of categories. This way the original `CLLocationManager` is reduced to a mere fa√ßade.\r\n\r\nDISCLAIMER: Method swizzling and category overrides are DANGEROUS PRACTICES and I strongly advise against them hitting production code. Take special care if you are binding to `CLLocationManager` properties with KVO as I haven't tested that scenario and KVO is very likely to interfere with the mentioned hacks. YOU HAVE BEEN WARNED.\r\n\r\n\r\n### Known limitations\r\n\r\nAs of now, AP is limited to location and heading data, that is, no significant-change, no regions, no nothing. In the future this may change if I happen to need that stuff or if I find an enthusiastic volunteer to code it for everyone's sake. :)\r\n\r\n\r\n### Installation\r\n\r\nHere are some guidelines for setting up AP in your project:\r\n- check out the latest revision (recommended to do so even if downloading the zip is easier)\r\n- add the `Core` files to your project \r\n- add one or more data sources (note that `APAgentDataSource` depends on `JSON`, if you add this data source you have to add Stig Brautaset's `SBJSON` too -- see the ThirdParty folder for a legacy version)\r\n\r\nSome hints on how to integrate it in your code (see the `APMobileHost` and `APDesktopHost` sample apps for details):\r\n- instantiate and set up the desired data source(s)\r\n- pass the data source(s) to `APAstralProjection` via the respective properties\r\n- kick off the data source by invoking `startGeneratingLocationEvents`\r\n\r\n\r\n### Contact\r\n\r\nIn case of doubts, bug reports or feature requests, you are welcome to visit the project home page at:\r\n\r\nhttp://github.com/lkxf/AstralProjection\r\n\r\n\r\n\r\nEnjoy!\r\n\r\nlkxf\r\n\r\n\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}